//
// DO NOT EDIT.
//
// Generated by the protocol buffer compiler.
// Source: flow/access/access.proto
//

//
// Copyright 2018, gRPC Authors All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import GRPC
import NIO
import Protobuf
import SwiftProtobuf


internal final class Flow_Access_AccessAPITestClient: Flow_Access_AccessAPIClientProtocol {
  private let fakeChannel: FakeChannel
  internal var defaultCallOptions: CallOptions
  internal var interceptors: Flow_Access_AccessAPIClientInterceptorFactoryProtocol?

  internal var channel: GRPCChannel {
    return self.fakeChannel
  }

  internal init(
    fakeChannel: FakeChannel = FakeChannel(),
    defaultCallOptions callOptions: CallOptions = CallOptions(),
    interceptors: Flow_Access_AccessAPIClientInterceptorFactoryProtocol? = nil
  ) {
    self.fakeChannel = fakeChannel
    self.defaultCallOptions = callOptions
    self.interceptors = interceptors
  }

  /// Make a unary response for the Ping RPC. This must be called
  /// before calling 'ping'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makePingResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_PingRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_PingRequest, Flow_Access_PingResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/Ping", requestHandler: requestHandler)
  }

  internal func enqueuePingResponse(
    _ response: Flow_Access_PingResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_PingRequest>) -> () = { _ in }
  )  {
    let stream = self.makePingResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'Ping'
  internal var hasPingResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/Ping")
  }

  /// Make a unary response for the GetLatestBlockHeader RPC. This must be called
  /// before calling 'getLatestBlockHeader'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makeGetLatestBlockHeaderResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetLatestBlockHeaderRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_GetLatestBlockHeaderRequest, Flow_Access_BlockHeaderResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/GetLatestBlockHeader", requestHandler: requestHandler)
  }

  internal func enqueueGetLatestBlockHeaderResponse(
    _ response: Flow_Access_BlockHeaderResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetLatestBlockHeaderRequest>) -> () = { _ in }
  )  {
    let stream = self.makeGetLatestBlockHeaderResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'GetLatestBlockHeader'
  internal var hasGetLatestBlockHeaderResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/GetLatestBlockHeader")
  }

  /// Make a unary response for the GetBlockHeaderByID RPC. This must be called
  /// before calling 'getBlockHeaderByID'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makeGetBlockHeaderByIDResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetBlockHeaderByIDRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_GetBlockHeaderByIDRequest, Flow_Access_BlockHeaderResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/GetBlockHeaderByID", requestHandler: requestHandler)
  }

  internal func enqueueGetBlockHeaderByIDResponse(
    _ response: Flow_Access_BlockHeaderResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetBlockHeaderByIDRequest>) -> () = { _ in }
  )  {
    let stream = self.makeGetBlockHeaderByIDResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'GetBlockHeaderByID'
  internal var hasGetBlockHeaderByIDResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/GetBlockHeaderByID")
  }

  /// Make a unary response for the GetBlockHeaderByHeight RPC. This must be called
  /// before calling 'getBlockHeaderByHeight'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makeGetBlockHeaderByHeightResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetBlockHeaderByHeightRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_GetBlockHeaderByHeightRequest, Flow_Access_BlockHeaderResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/GetBlockHeaderByHeight", requestHandler: requestHandler)
  }

  internal func enqueueGetBlockHeaderByHeightResponse(
    _ response: Flow_Access_BlockHeaderResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetBlockHeaderByHeightRequest>) -> () = { _ in }
  )  {
    let stream = self.makeGetBlockHeaderByHeightResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'GetBlockHeaderByHeight'
  internal var hasGetBlockHeaderByHeightResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/GetBlockHeaderByHeight")
  }

  /// Make a unary response for the GetLatestBlock RPC. This must be called
  /// before calling 'getLatestBlock'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makeGetLatestBlockResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetLatestBlockRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_GetLatestBlockRequest, Flow_Access_BlockResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/GetLatestBlock", requestHandler: requestHandler)
  }

  internal func enqueueGetLatestBlockResponse(
    _ response: Flow_Access_BlockResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetLatestBlockRequest>) -> () = { _ in }
  )  {
    let stream = self.makeGetLatestBlockResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'GetLatestBlock'
  internal var hasGetLatestBlockResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/GetLatestBlock")
  }

  /// Make a unary response for the GetBlockByID RPC. This must be called
  /// before calling 'getBlockByID'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makeGetBlockByIDResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetBlockByIDRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_GetBlockByIDRequest, Flow_Access_BlockResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/GetBlockByID", requestHandler: requestHandler)
  }

  internal func enqueueGetBlockByIDResponse(
    _ response: Flow_Access_BlockResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetBlockByIDRequest>) -> () = { _ in }
  )  {
    let stream = self.makeGetBlockByIDResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'GetBlockByID'
  internal var hasGetBlockByIDResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/GetBlockByID")
  }

  /// Make a unary response for the GetBlockByHeight RPC. This must be called
  /// before calling 'getBlockByHeight'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makeGetBlockByHeightResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetBlockByHeightRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_GetBlockByHeightRequest, Flow_Access_BlockResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/GetBlockByHeight", requestHandler: requestHandler)
  }

  internal func enqueueGetBlockByHeightResponse(
    _ response: Flow_Access_BlockResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetBlockByHeightRequest>) -> () = { _ in }
  )  {
    let stream = self.makeGetBlockByHeightResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'GetBlockByHeight'
  internal var hasGetBlockByHeightResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/GetBlockByHeight")
  }

  /// Make a unary response for the GetCollectionByID RPC. This must be called
  /// before calling 'getCollectionByID'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makeGetCollectionByIDResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetCollectionByIDRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_GetCollectionByIDRequest, Flow_Access_CollectionResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/GetCollectionByID", requestHandler: requestHandler)
  }

  internal func enqueueGetCollectionByIDResponse(
    _ response: Flow_Access_CollectionResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetCollectionByIDRequest>) -> () = { _ in }
  )  {
    let stream = self.makeGetCollectionByIDResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'GetCollectionByID'
  internal var hasGetCollectionByIDResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/GetCollectionByID")
  }

  /// Make a unary response for the SendTransaction RPC. This must be called
  /// before calling 'sendTransaction'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makeSendTransactionResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_SendTransactionRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_SendTransactionRequest, Flow_Access_SendTransactionResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/SendTransaction", requestHandler: requestHandler)
  }

  internal func enqueueSendTransactionResponse(
    _ response: Flow_Access_SendTransactionResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_SendTransactionRequest>) -> () = { _ in }
  )  {
    let stream = self.makeSendTransactionResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'SendTransaction'
  internal var hasSendTransactionResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/SendTransaction")
  }

  /// Make a unary response for the GetTransaction RPC. This must be called
  /// before calling 'getTransaction'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makeGetTransactionResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetTransactionRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_GetTransactionRequest, Flow_Access_TransactionResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/GetTransaction", requestHandler: requestHandler)
  }

  internal func enqueueGetTransactionResponse(
    _ response: Flow_Access_TransactionResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetTransactionRequest>) -> () = { _ in }
  )  {
    let stream = self.makeGetTransactionResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'GetTransaction'
  internal var hasGetTransactionResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/GetTransaction")
  }

  /// Make a unary response for the GetTransactionResult RPC. This must be called
  /// before calling 'getTransactionResult'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makeGetTransactionResultResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetTransactionRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_GetTransactionRequest, Flow_Access_TransactionResultResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/GetTransactionResult", requestHandler: requestHandler)
  }

  internal func enqueueGetTransactionResultResponse(
    _ response: Flow_Access_TransactionResultResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetTransactionRequest>) -> () = { _ in }
  )  {
    let stream = self.makeGetTransactionResultResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'GetTransactionResult'
  internal var hasGetTransactionResultResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/GetTransactionResult")
  }

  /// Make a unary response for the GetTransactionResultByIndex RPC. This must be called
  /// before calling 'getTransactionResultByIndex'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makeGetTransactionResultByIndexResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetTransactionByIndexRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_GetTransactionByIndexRequest, Flow_Access_TransactionResultResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/GetTransactionResultByIndex", requestHandler: requestHandler)
  }

  internal func enqueueGetTransactionResultByIndexResponse(
    _ response: Flow_Access_TransactionResultResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetTransactionByIndexRequest>) -> () = { _ in }
  )  {
    let stream = self.makeGetTransactionResultByIndexResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'GetTransactionResultByIndex'
  internal var hasGetTransactionResultByIndexResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/GetTransactionResultByIndex")
  }

  /// Make a unary response for the GetTransactionResultsByBlockID RPC. This must be called
  /// before calling 'getTransactionResultsByBlockID'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makeGetTransactionResultsByBlockIDResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetTransactionsByBlockIDRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_GetTransactionsByBlockIDRequest, Flow_Access_TransactionResultsResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/GetTransactionResultsByBlockID", requestHandler: requestHandler)
  }

  internal func enqueueGetTransactionResultsByBlockIDResponse(
    _ response: Flow_Access_TransactionResultsResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetTransactionsByBlockIDRequest>) -> () = { _ in }
  )  {
    let stream = self.makeGetTransactionResultsByBlockIDResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'GetTransactionResultsByBlockID'
  internal var hasGetTransactionResultsByBlockIDResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/GetTransactionResultsByBlockID")
  }

  /// Make a unary response for the GetTransactionsByBlockID RPC. This must be called
  /// before calling 'getTransactionsByBlockID'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makeGetTransactionsByBlockIDResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetTransactionsByBlockIDRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_GetTransactionsByBlockIDRequest, Flow_Access_TransactionsResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/GetTransactionsByBlockID", requestHandler: requestHandler)
  }

  internal func enqueueGetTransactionsByBlockIDResponse(
    _ response: Flow_Access_TransactionsResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetTransactionsByBlockIDRequest>) -> () = { _ in }
  )  {
    let stream = self.makeGetTransactionsByBlockIDResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'GetTransactionsByBlockID'
  internal var hasGetTransactionsByBlockIDResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/GetTransactionsByBlockID")
  }

  /// Make a unary response for the GetAccount RPC. This must be called
  /// before calling 'getAccount'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makeGetAccountResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetAccountRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_GetAccountRequest, Flow_Access_GetAccountResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/GetAccount", requestHandler: requestHandler)
  }

  internal func enqueueGetAccountResponse(
    _ response: Flow_Access_GetAccountResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetAccountRequest>) -> () = { _ in }
  )  {
    let stream = self.makeGetAccountResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'GetAccount'
  internal var hasGetAccountResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/GetAccount")
  }

  /// Make a unary response for the GetAccountAtLatestBlock RPC. This must be called
  /// before calling 'getAccountAtLatestBlock'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makeGetAccountAtLatestBlockResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetAccountAtLatestBlockRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_GetAccountAtLatestBlockRequest, Flow_Access_AccountResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/GetAccountAtLatestBlock", requestHandler: requestHandler)
  }

  internal func enqueueGetAccountAtLatestBlockResponse(
    _ response: Flow_Access_AccountResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetAccountAtLatestBlockRequest>) -> () = { _ in }
  )  {
    let stream = self.makeGetAccountAtLatestBlockResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'GetAccountAtLatestBlock'
  internal var hasGetAccountAtLatestBlockResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/GetAccountAtLatestBlock")
  }

  /// Make a unary response for the GetAccountAtBlockHeight RPC. This must be called
  /// before calling 'getAccountAtBlockHeight'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makeGetAccountAtBlockHeightResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetAccountAtBlockHeightRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_GetAccountAtBlockHeightRequest, Flow_Access_AccountResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/GetAccountAtBlockHeight", requestHandler: requestHandler)
  }

  internal func enqueueGetAccountAtBlockHeightResponse(
    _ response: Flow_Access_AccountResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetAccountAtBlockHeightRequest>) -> () = { _ in }
  )  {
    let stream = self.makeGetAccountAtBlockHeightResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'GetAccountAtBlockHeight'
  internal var hasGetAccountAtBlockHeightResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/GetAccountAtBlockHeight")
  }

  /// Make a unary response for the ExecuteScriptAtLatestBlock RPC. This must be called
  /// before calling 'executeScriptAtLatestBlock'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makeExecuteScriptAtLatestBlockResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_ExecuteScriptAtLatestBlockRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_ExecuteScriptAtLatestBlockRequest, Flow_Access_ExecuteScriptResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/ExecuteScriptAtLatestBlock", requestHandler: requestHandler)
  }

  internal func enqueueExecuteScriptAtLatestBlockResponse(
    _ response: Flow_Access_ExecuteScriptResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_ExecuteScriptAtLatestBlockRequest>) -> () = { _ in }
  )  {
    let stream = self.makeExecuteScriptAtLatestBlockResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'ExecuteScriptAtLatestBlock'
  internal var hasExecuteScriptAtLatestBlockResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/ExecuteScriptAtLatestBlock")
  }

  /// Make a unary response for the ExecuteScriptAtBlockID RPC. This must be called
  /// before calling 'executeScriptAtBlockID'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makeExecuteScriptAtBlockIDResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_ExecuteScriptAtBlockIDRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_ExecuteScriptAtBlockIDRequest, Flow_Access_ExecuteScriptResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/ExecuteScriptAtBlockID", requestHandler: requestHandler)
  }

  internal func enqueueExecuteScriptAtBlockIDResponse(
    _ response: Flow_Access_ExecuteScriptResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_ExecuteScriptAtBlockIDRequest>) -> () = { _ in }
  )  {
    let stream = self.makeExecuteScriptAtBlockIDResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'ExecuteScriptAtBlockID'
  internal var hasExecuteScriptAtBlockIDResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/ExecuteScriptAtBlockID")
  }

  /// Make a unary response for the ExecuteScriptAtBlockHeight RPC. This must be called
  /// before calling 'executeScriptAtBlockHeight'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makeExecuteScriptAtBlockHeightResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_ExecuteScriptAtBlockHeightRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_ExecuteScriptAtBlockHeightRequest, Flow_Access_ExecuteScriptResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/ExecuteScriptAtBlockHeight", requestHandler: requestHandler)
  }

  internal func enqueueExecuteScriptAtBlockHeightResponse(
    _ response: Flow_Access_ExecuteScriptResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_ExecuteScriptAtBlockHeightRequest>) -> () = { _ in }
  )  {
    let stream = self.makeExecuteScriptAtBlockHeightResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'ExecuteScriptAtBlockHeight'
  internal var hasExecuteScriptAtBlockHeightResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/ExecuteScriptAtBlockHeight")
  }

  /// Make a unary response for the GetEventsForHeightRange RPC. This must be called
  /// before calling 'getEventsForHeightRange'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makeGetEventsForHeightRangeResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetEventsForHeightRangeRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_GetEventsForHeightRangeRequest, Flow_Access_EventsResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/GetEventsForHeightRange", requestHandler: requestHandler)
  }

  internal func enqueueGetEventsForHeightRangeResponse(
    _ response: Flow_Access_EventsResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetEventsForHeightRangeRequest>) -> () = { _ in }
  )  {
    let stream = self.makeGetEventsForHeightRangeResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'GetEventsForHeightRange'
  internal var hasGetEventsForHeightRangeResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/GetEventsForHeightRange")
  }

  /// Make a unary response for the GetEventsForBlockIDs RPC. This must be called
  /// before calling 'getEventsForBlockIDs'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makeGetEventsForBlockIDsResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetEventsForBlockIDsRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_GetEventsForBlockIDsRequest, Flow_Access_EventsResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/GetEventsForBlockIDs", requestHandler: requestHandler)
  }

  internal func enqueueGetEventsForBlockIDsResponse(
    _ response: Flow_Access_EventsResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetEventsForBlockIDsRequest>) -> () = { _ in }
  )  {
    let stream = self.makeGetEventsForBlockIDsResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'GetEventsForBlockIDs'
  internal var hasGetEventsForBlockIDsResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/GetEventsForBlockIDs")
  }

  /// Make a unary response for the GetNetworkParameters RPC. This must be called
  /// before calling 'getNetworkParameters'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makeGetNetworkParametersResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetNetworkParametersRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_GetNetworkParametersRequest, Flow_Access_GetNetworkParametersResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/GetNetworkParameters", requestHandler: requestHandler)
  }

  internal func enqueueGetNetworkParametersResponse(
    _ response: Flow_Access_GetNetworkParametersResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetNetworkParametersRequest>) -> () = { _ in }
  )  {
    let stream = self.makeGetNetworkParametersResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'GetNetworkParameters'
  internal var hasGetNetworkParametersResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/GetNetworkParameters")
  }

  /// Make a unary response for the GetLatestProtocolStateSnapshot RPC. This must be called
  /// before calling 'getLatestProtocolStateSnapshot'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makeGetLatestProtocolStateSnapshotResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetLatestProtocolStateSnapshotRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_GetLatestProtocolStateSnapshotRequest, Flow_Access_ProtocolStateSnapshotResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/GetLatestProtocolStateSnapshot", requestHandler: requestHandler)
  }

  internal func enqueueGetLatestProtocolStateSnapshotResponse(
    _ response: Flow_Access_ProtocolStateSnapshotResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetLatestProtocolStateSnapshotRequest>) -> () = { _ in }
  )  {
    let stream = self.makeGetLatestProtocolStateSnapshotResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'GetLatestProtocolStateSnapshot'
  internal var hasGetLatestProtocolStateSnapshotResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/GetLatestProtocolStateSnapshot")
  }

  /// Make a unary response for the GetExecutionResultForBlockID RPC. This must be called
  /// before calling 'getExecutionResultForBlockID'. See also 'FakeUnaryResponse'.
  ///
  /// - Parameter requestHandler: a handler for request parts sent by the RPC.
  internal func makeGetExecutionResultForBlockIDResponseStream(
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetExecutionResultForBlockIDRequest>) -> () = { _ in }
  ) -> FakeUnaryResponse<Flow_Access_GetExecutionResultForBlockIDRequest, Flow_Access_ExecutionResultForBlockIDResponse> {
    return self.fakeChannel.makeFakeUnaryResponse(path: "/flow.access.AccessAPI/GetExecutionResultForBlockID", requestHandler: requestHandler)
  }

  internal func enqueueGetExecutionResultForBlockIDResponse(
    _ response: Flow_Access_ExecutionResultForBlockIDResponse,
    _ requestHandler: @escaping (FakeRequestPart<Flow_Access_GetExecutionResultForBlockIDRequest>) -> () = { _ in }
  )  {
    let stream = self.makeGetExecutionResultForBlockIDResponseStream(requestHandler)
    // This is the only operation on the stream; try! is fine.
    try! stream.sendMessage(response)
  }

  /// Returns true if there are response streams enqueued for 'GetExecutionResultForBlockID'
  internal var hasGetExecutionResultForBlockIDResponsesRemaining: Bool {
    return self.fakeChannel.hasFakeResponseEnqueued(forPath: "/flow.access.AccessAPI/GetExecutionResultForBlockID")
  }
}

