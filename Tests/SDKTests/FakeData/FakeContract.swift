//
//  FakeContract.swift
// 
//  Created by Scott on 2022/6/5.
//  Copyright Â© 2022 portto. All rights reserved.
//

import Foundation

enum FakeContract {

    static var flowToken: String {
        "import FungibleToken from 0x9a0766d93b6608b7\n\npub contract FlowToken: FungibleToken {\n\n    // Total supply of Flow tokens in existence\n    pub var totalSupply: UFix64\n\n    // Event that is emitted when the contract is created\n    pub event TokensInitialized(initialSupply: UFix64)\n\n    // Event that is emitted when tokens are withdrawn from a Vault\n    pub event TokensWithdrawn(amount: UFix64, from: Address?)\n\n    // Event that is emitted when tokens are deposited to a Vault\n    pub event TokensDeposited(amount: UFix64, to: Address?)\n\n    // Event that is emitted when new tokens are minted\n    pub event TokensMinted(amount: UFix64)\n\n    // Event that is emitted when tokens are destroyed\n    pub event TokensBurned(amount: UFix64)\n\n    // Event that is emitted when a new minter resource is created\n    pub event MinterCreated(allowedAmount: UFix64)\n\n    // Event that is emitted when a new burner resource is created\n    pub event BurnerCreated()\n\n    // Vault\n    //\n    // Each user stores an instance of only the Vault in their storage\n    // The functions in the Vault and governed by the pre and post conditions\n    // in FungibleToken when they are called.\n    // The checks happen at runtime whenever a function is called.\n    //\n    // Resources can only be created in the context of the contract that they\n    // are defined in, so there is no way for a malicious user to create Vaults\n    // out of thin air. A special Minter resource needs to be defined to mint\n    // new tokens.\n    //\n    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {\n\n        // holds the balance of a users tokens\n        pub var balance: UFix64\n\n        // initialize the balance at resource creation time\n        init(balance: UFix64) {\n            self.balance = balance\n        }\n\n        // withdraw\n        //\n        // Function that takes an integer amount as an argument\n        // and withdraws that amount from the Vault.\n        // It creates a new temporary Vault that is used to hold\n        // the money that is being transferred. It returns the newly\n        // created Vault to the context that called so it can be deposited\n        // elsewhere.\n        //\n        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {\n            self.balance = self.balance - amount\n            emit TokensWithdrawn(amount: amount, from: self.owner?.address)\n            return <-create Vault(balance: amount)\n        }\n\n        // deposit\n        //\n        // Function that takes a Vault object as an argument and adds\n        // its balance to the balance of the owners Vault.\n        // It is allowed to destroy the sent Vault because the Vault\n        // was a temporary holder of the tokens. The Vault's balance has\n        // been consumed and therefore can be destroyed.\n        pub fun deposit(from: @FungibleToken.Vault) {\n            let vault <- from as! @FlowToken.Vault\n            self.balance = self.balance + vault.balance\n            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)\n            vault.balance = 0.0\n            destroy vault\n        }\n\n        destroy() {\n            FlowToken.totalSupply = FlowToken.totalSupply - self.balance\n        }\n    }\n\n    // createEmptyVault\n    //\n    // Function that creates a new Vault with a balance of zero\n    // and returns it to the calling context. A user must call this function\n    // and store the returned Vault in their storage in order to allow their\n    // account to be able to receive deposits of this token type.\n    //\n    pub fun createEmptyVault(): @FungibleToken.Vault {\n        return <-create Vault(balance: 0.0)\n    }\n\n    pub resource Administrator {\n        // createNewMinter\n        //\n        // Function that creates and returns a new minter resource\n        //\n        pub fun createNewMinter(allowedAmount: UFix64): @Minter {\n            emit MinterCreated(allowedAmount: allowedAmount)\n            return <-create Minter(allowedAmount: allowedAmount)\n        }\n\n        // createNewBurner\n        //\n        // Function that creates and returns a new burner resource\n        //\n        pub fun createNewBurner(): @Burner {\n            emit BurnerCreated()\n            return <-create Burner()\n        }\n    }\n\n    // Minter\n    //\n    // Resource object that token admin accounts can hold to mint new tokens.\n    //\n    pub resource Minter {\n\n        // the amount of tokens that the minter is allowed to mint\n        pub var allowedAmount: UFix64\n\n        // mintTokens\n        //\n        // Function that mints new tokens, adds them to the total supply,\n        // and returns them to the calling context.\n        //\n        pub fun mintTokens(amount: UFix64): @FlowToken.Vault {\n            pre {\n                amount > UFix64(0): \"Amount minted must be greater than zero\"\n                amount <= self.allowedAmount: \"Amount minted must be less than the allowed amount\"\n            }\n            FlowToken.totalSupply = FlowToken.totalSupply + amount\n            self.allowedAmount = self.allowedAmount - amount\n            emit TokensMinted(amount: amount)\n            return <-create Vault(balance: amount)\n        }\n\n        init(allowedAmount: UFix64) {\n            self.allowedAmount = allowedAmount\n        }\n    }\n    \n    // Burner\n    //\n    // Resource object that token admin accounts can hold to burn tokens.\n    //\n    pub resource Burner {\n\n        // burnTokens\n        //\n        // Function that destroys a Vault instance, effectively burning the tokens.\n        //\n        // Note: the burned tokens are automatically subtracted from the \n        // total supply in the Vault destructor.\n        //\n        pub fun burnTokens(from: @FungibleToken.Vault) {\n            let vault <- from as! @FlowToken.Vault\n            let amount = vault.balance\n            destroy vault\n            emit TokensBurned(amount: amount)\n        }\n    }\n\n    init(adminAccount: AuthAccount) {\n        self.totalSupply = 0.0\n\n        // Create the Vault with the total supply of tokens and save it in storage\n        //\n        let vault <- create Vault(balance: self.totalSupply)\n        adminAccount.save(<-vault, to: /storage/flowTokenVault)\n\n        // Create a public capability to the stored Vault that only exposes\n        // the `deposit` method through the `Receiver` interface\n        //\n        adminAccount.link<&FlowToken.Vault{FungibleToken.Receiver}>(\n            /public/flowTokenReceiver,\n            target: /storage/flowTokenVault\n        )\n\n        // Create a public capability to the stored Vault that only exposes\n        // the `balance` field through the `Balance` interface\n        //\n        adminAccount.link<&FlowToken.Vault{FungibleToken.Balance}>(\n            /public/flowTokenBalance,\n            target: /storage/flowTokenVault\n        )\n\n        let admin <- create Administrator()\n        adminAccount.save(<-admin, to: /storage/flowTokenAdmin)\n\n        // Emit an event that shows that the contract was initialized\n        emit TokensInitialized(initialSupply: self.totalSupply)\n    }\n}\n"
    }
}
